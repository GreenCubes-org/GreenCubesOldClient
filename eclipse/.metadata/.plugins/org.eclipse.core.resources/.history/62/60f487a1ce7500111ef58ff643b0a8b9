package net.minecraft.src;

import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Scanner;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.lwjgl.input.Keyboard;

import ru.greencubes.util.Configuration;
import ru.greencubes.util.ConfigurationNode;

import net.minecraft.client.Minecraft;

public class GChat {

	private static final int SHIFT = 1;
	private static final int CTRL = 2;
	private static final SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	private static final Pattern objectPattern = Pattern.compile("\247o(.+)\247o(.+)\247o");
	private static final Pattern colorPattern = Pattern.compile("\247.");
	//private static final Pattern shiftPattern = Pattern.compile("(shift|lshift|rshift)");
	//private static final Pattern ctrlPattern = Pattern.compile("(ctrl|control|lctrl|rctrl|lcontrol|rcontrol)");
	private static final Pattern empty = Pattern.compile("^[ ]*$");
	private static final Pattern channelPattern = Pattern.compile("\247n");
	private static final int chatWidth = 340;
	private static final StringBuilder emptySb = new StringBuilder(0);
	public static final float tabWidth = 152 / 2;
	
	public static Minecraft mc;
	private final Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
	public final int dotsWidth;
	
	public int lines = 20;
	public boolean locked = false;
	public final Map<Integer,String>[] bindings = (Map<Integer,String>[]) new Map[4];
	public final List<String> lastMessagesSent = new ArrayList<String>();
	private int lastMessagesIndex = -1;
	private final OutputStreamWriter log;
	public final Map<Integer,GChannel> channels = new HashMap<Integer,GChannel>();
	public final List<GTab> tabs = new ArrayList<GTab>();
	public final List<String> pastCommands = new ArrayList<String>();
	public int commandScroll = 0;
	public GTab mainTab;
	public int chatScroll = 0;
	public int maxHistoryPerTab = 200;
	public int bgColor = 0x66000000;
	public int tabScroll = 0;
	public GTab activeTab;
	public int activeTabIndex = 0;
	public Configuration config;
	public File chatDir;
	private int nextId = 1;
	
	public GChat(Minecraft mc) throws IOException {
		this.mc = mc;
		dotsWidth = mc.fontRenderer.getStringWidth("...");
		chatDir = new File(Minecraft.getMinecraftDir(),"chat/");
		if(!chatDir.exists())
			chatDir.mkdirs();
		if(!chatDir.isDirectory())
			throw new IOException("Chat folder is not directory!");
		File logFile = new File(chatDir, "full_chat.log");
		if(!logFile.exists())
			logFile.createNewFile();
		log = new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(logFile, true)));
		for(int i = 0; i < bindings.length; ++i)
			bindings[i] = new HashMap<Integer,String>();
		File configFile = new File(chatDir,"config.yml");
		boolean shouldSave = false;
		if(!configFile.exists()) {
			configFile.createNewFile();
			FileWriter fw = new FileWriter(configFile);
			fw.write("node: node");
			fw.close();
			shouldSave = true;
		}
		config = new Configuration(configFile);
		config.load();
		lines = config.getInt("max-lines", 20);
		if(lines < 1)
			lines = 20;
		locked = config.getBoolean("no-hide", false);
		maxHistoryPerTab = config.getInt("max-chat-history", 200);
		if(maxHistoryPerTab < 1)
			maxHistoryPerTab = 200;
		bgColor = Integer.parseInt(config.getString("bg-color","40000000"), 16);
		List<ConfigurationNode> nodes = config.getNodeList("tabs", new ArrayList<ConfigurationNode>());
		boolean hasMain = false;
		for(int i = 0; i < nodes.size(); ++i) {
			ConfigurationNode node = nodes.get(i);
			String name = node.getString("name");
			int position = node.getInt("position", -1);
			boolean isSystem = !hasMain && node.getBoolean("main", false);
			if(name != null && position >= 0) {
				GTab tab = new GTab(this, name);
				tab.isSystem = isSystem;
				if(isSystem) {
					hasMain = true;
					mainTab = tab;
					activeTab = tab;
				}
				tabs.add(position, tab);
				tab.readyToJoin = node.getIntList("channels", new ArrayList<Integer>());
			}
		}
		for(int i = 0; i < tabs.size(); ++i)
			if(tabs.get(i) == null)
				tabs.remove(i--);
		if(!hasMain) {
			shouldSave = true;
			GTab tab = new GTab(this, "Main");
			tab.isSystem = true;
			mainTab = tab;
			activeTab = tab;
			tabs.add(0, tab);
		}
		nodes = config.getNodeList("binds", new ArrayList<ConfigurationNode>());
		for(int i = 0; i < nodes.size(); ++i) {
			ConfigurationNode node = nodes.get(i);
			int sub = node.getInt("sub-key", -1);
			int key = node.getInt("key",-1);
			String command = node.getString("command");
			if(sub >= 0 && sub <= 3 && Keyboard.getKeyName(key) != null && command != null)
				bindings[sub].put(key, command);
		}
		if(shouldSave)
			saveConfig();
	}
	
	public StringBuilder processKeyInput(StringBuilder message) {
		if(message.length() > 1 && message.charAt(0) == '/') {
			String[] split = message.toString().split(" ");
			if(split.length > 0 && split[0].length() < message.length()) {
				String ali = split[0].substring(1);
				Collection<GChannel> channels = activeTab.attachedChannels.values();
				Iterator<GChannel> i = channels.iterator();
				while(i.hasNext()) {
					GChannel c = i.next();
					for(int n = 0; n < c.aliases.size(); ++n)
						if(c.aliases.get(n).equalsIgnoreCase(ali)) {
							activeTab.activeChannel = c;
							activeTab.prefix = c.name + ":";
							return new StringBuilder(message.substring(ali.length() + 2, message.length()));
						}
				}
				if(ali.equalsIgnoreCase("w")) {
					activeTab.prefix = this.channels.get(2).name + ":";
					activeTab.sendPrefix = "/w ";
					return new StringBuilder(message.substring(ali.length() + 2, message.length()));
				} else if(ali.equalsIgnoreCase("m")) {
					if(split.length > 1 && message.length() > split[0].length() + split[1].length() + 1) {
						activeTab.prefix = "PM to " + split[1] + ":";
						activeTab.sendPrefix = "/m " + split[1] + " ";
						return new StringBuilder(message.substring(ali.length() + 3 + split[1].length(), message.length()));
					}
				}
			}
		}
		return message;
	}
	
	public List<StringBuilder> processChatDisplay(CharSequence line) {
		List<StringBuilder> list = new ArrayList<StringBuilder>();
		float lineWidth = 0;
		StringBuilder nextLine = new StringBuilder();
		for(int i = 0; i < line.length(); ++i) {
			char c = line.charAt(i);
			int id = ChatAllowedCharacters.allowedCharacters.indexOf(c);
			if(id >= 0) {
				if(lineWidth + mc.fontRenderer.charWidth[id + 32] <= chatWidth) {
					lineWidth += mc.fontRenderer.charWidth[id + 32];
					nextLine.append(c);
				} else {
					list.add(nextLine);
					lineWidth = mc.fontRenderer.charWidth[id + 32];
					nextLine = new StringBuilder();
					nextLine.append(c);
				}
			}
		}
		if(nextLine.length() > 0)
			list.add(nextLine);
		if(list.size() == 0)
			list.add(emptySb);
		return list;
	}
	
	private boolean executeScript(String name) {
		File f = new File(chatDir, name);
		Scanner reader;
		try {
			reader = new Scanner(f, "UTF-8");
		} catch(FileNotFoundException e) {
			return false;
		}
		try {
			while(reader.hasNextLine())  {
				String command = reader.nextLine();
				if(command.endsWith("\\")) {
					GuiChat chat = new GuiChat();
					mc.displayGuiScreen(chat);
					chat.message = processKeyInput(new StringBuilder(command.substring(0, command.length() - 1)));
					chat.cursorPosition = chat.message.length();
					return true;
				}
				processOutput(command);
			}
		} finally {
			reader.close();
		}
		return true;
	}
	
	public void saveConfig() {
		File configFile = new File(chatDir,"config.yml");
		try {
			configFile.delete();
			configFile.createNewFile();
		} catch(IOException e1) {
			e1.printStackTrace();
		}
		config = new Configuration(configFile);
		config.setProperty("max-lines", lines);
		config.setProperty("no-hide", locked);
		config.setProperty("max-chat-history", maxHistoryPerTab);
		config.setProperty("bg-color", Integer.toHexString(bgColor));
		List<Object> nodes = new ArrayList<Object>();
		for(int i = 0; i < tabs.size(); ++i) {
			Map<String,Object> tabNode = new HashMap<String,Object>();
			GTab tab = tabs.get(i);
			tabNode.put("position", i);
			tabNode.put("name", tab.name);
			if(tab.isSystem)
				tabNode.put("main", tab.isSystem);
			List<Integer> channels = new ArrayList<Integer>();
			for(int n = 0; n < tab.readyToJoin.size(); ++n)
				channels.add(tab.readyToJoin.get(n));
			channels.addAll(tab.attachedChannels.keySet());
			if(channels.size() > 0)
				tabNode.put("channels",channels);
			nodes.add(tabNode);
		}
		config.setProperty("tabs", nodes);
		nodes = new ArrayList<Object>();
		for(int i = 0; i < bindings.length; ++i) {
			Map<Integer,String> bindMap = bindings[i];
			Iterator<Entry<Integer,String>> iterator = bindMap.entrySet().iterator();
			while(iterator.hasNext()) {
				Entry<Integer,String> e = iterator.next();
				Map<String,Object> node = new HashMap<String,Object>();
				node.put("sub-key", i);
				node.put("key", e.getKey());
				node.put("command", e.getValue());
				nodes.add(node);
			}
		}
		config.setProperty("binds", nodes);
		config.save();
	}
	
	public void logMessage(String message, String channel) {
		try {
			message = objectPattern.matcher(message).replaceAll("$1");
			message = colorPattern.matcher(message).replaceAll("");
			log.append(dateFormatter.format(Long.valueOf(System.currentTimeMillis())));
			log.append(" [");
			log.append(channel);
			log.append("] ");
			log.append(message);
			log.append('\n');
			log.flush();
			//System.out.println("[" + channel + "] " + message);
		} catch(IOException e) {
			e.printStackTrace();
		}
	}
	
	public void tick() {
		for(int i = 0; i < tabs.size(); ++i) {
			GTab tab = tabs.get(i);
			for(int n = 0; n < tab.lines.size(); ++n)
				tab.lines.get(n).age++;
		}
	}
	
	public boolean pressKey(int key) {
		int sub = 0;
		if(Keyboard.isKeyDown(Keyboard.KEY_LCONTROL) || Keyboard.isKeyDown(Keyboard.KEY_RCONTROL))
			sub += CTRL;
		if(Keyboard.isKeyDown(Keyboard.KEY_LSHIFT) || Keyboard.isKeyDown(Keyboard.KEY_RSHIFT))
			sub += SHIFT;
		String command = bindings[sub].get(Integer.valueOf(key));
		if(command != null) {
			if(command.endsWith("\\")) {
				GuiChat chat = new GuiChat();
				mc.displayGuiScreen(chat);
				chat.message = processKeyInput(new StringBuilder(command.substring(0, command.length() - 1)));
				chat.cursorPosition = chat.message.length();
				return true;
			}
			processOutput(command);
			return true;
		}
		return false;
	}
	
	public void processInput(String message, int channel) {
		message = channelPattern.matcher(message).replaceAll(Integer.toString(channel));
		String test = colorPattern.matcher(message).replaceAll("");
		if(empty.matcher(test).matches())
			return;
		GChannel c = channels.get(channel);
		if(c == null) {
			logMessage(message, "SYSTEM");
			mainTab.addNewLine(message);
			if(activeTab != mainTab)
				activeTab.addNewLine(message);
		} else {
			logMessage(message, c.name);
			for(int i = 0; i < c.attachedTabs.size(); ++i) {
				c.attachedTabs.get(i).addNewLine(message);
				if(c.attachedTabs.get(i) != activeTab && (!c.isSystem || !c.attachedTabs.get(i).isSystem))
					c.attachedTabs.get(i).hasNewMessage = true;
			}
			if(c.isSystem && !c.attachedTabs.contains(mainTab))
				mainTab.addNewLine(message);
		}
	}
	
	public void processOutput(String message) {
		if(empty.matcher(message).matches())
			return;
		if(message.startsWith("~")) {
			message = message.substring(1);
			String[] split = message.split(" ");
			if(split[0].equals("bind")) {
				if(split.length < 3) {
					activeTab.addNewLine("Использование: ~bind <клавиша> <команда...>");
				} else {
					String command = join(split, " ", 2);
					int sub = 0;
					split[1] = split[1].toLowerCase();
					if(split[1].contains("shift-")) {
						sub += SHIFT;
						split[1] = split[1].replace("shift-", "");
					}
					if(split[1].contains("ctrl-")) {
						sub += CTRL;
						split[1] = split[1].replace("ctrl-", "");
					}
					int key = Keyboard.getKeyIndex(split[1].toUpperCase());
					if(key == 0) {
						activeTab.addNewLine("Указанная клавиша не найдена!");
					} else {
						bindings[sub].put(key, command);
						saveConfig();
						activeTab.addNewLine("Новое сочетание клавиш добавлено!");
					}
				}
			} else if(split[0].equals("script")) {
				if(split.length < 2) {
					activeTab.addNewLine("Использование: ~script <имя файла...>");
				} else {
					String file = join(split, " ", 1);
					if(!executeScript(file)) {
						activeTab.addNewLine("\2474Ошибка выполнения скрипта!");
					}
				}
			} else if(split[0].equals("unbind")) {
				if(split.length < 2) {
					activeTab.addNewLine("Использование: ~unbind <клавиша>");
				} else {
					int sub = 0;
					split[1] = split[1].toLowerCase();
					if(split[1].contains("shift-")) {
						sub += SHIFT;
						split[1] = split[1].replace("shift-", "");
					}
					if(split[1].contains("ctrl-")) {
						sub += CTRL;
						split[1] = split[1].replace("ctrl-", "");
					}
					int key = Keyboard.getKeyIndex(split[1].toUpperCase());
					if(key == 0) {
						activeTab.addNewLine("Указанная клавиша не найдена!");
					} else {
						bindings[sub].remove(key);
						activeTab.addNewLine("Сочетание клавиш удалено!");
					}
				}
			}
		} else {
			if(activeTab.sendPrefix != null && !message.startsWith("/"))
				message = activeTab.sendPrefix + message;
			//System.out.println("Out: " + message);
			mc.getSendQueue().addToSendQueue(new Packet3Chat(message, activeTab.activeChannel != null && !message.startsWith("/") ? activeTab.activeChannel.id : 1));
		}
	}
	
	public void copy(String s) {
        clipboard.setContents(new StringSelection(s), null);
    }

    public String paste() {
        String s = "";
        Transferable transferable = clipboard.getContents(null);
        if(transferable != null && transferable.isDataFlavorSupported(DataFlavor.stringFlavor))
            try {
                s = (String)transferable.getTransferData(DataFlavor.stringFlavor);
            } catch(UnsupportedFlavorException unsupportedflavorexception) {
            } catch(IOException ioexception) { }
        return s;
    }
    
    public void handleChannel(Packet204Channel packet) {
    	if(packet.update) {
	    	GChannel c = channels.get(packet.channelId);
	    	if(c != null) {
	    		c.name = packet.channelName;
	    		c.isSystem = true;
	    		return;
	    	}
	    	c = new GChannel(packet.channelId, packet.channelName, packet.isSystem);
	    	channels.put(c.id, c);
	    	if(packet.channelAlias.length() > 0)
	    		c.aliases.add(packet.channelAlias);
	    	c.aliases.add(Integer.toString(nextId++));
	    	for(int i = 0; i < tabs.size(); ++i) {
	    		GTab tab = tabs.get(i);
	    		if(tab.readyToJoin.contains(packet.channelId)) {
	    			tab.attachedChannels.put(c.id, c);
	    			tab.readyToJoin.remove(Integer.valueOf(c.id));
	    			c.attachedTabs.add(tab);
	    		} else if(tab.isSystem && c.isSystem) {
	    			tab.attachedChannels.put(c.id, c);
	    		}
	    	}
    	} else {
    		
    	}
    	saveConfig();
    }
    
    public void handleChat(Packet3Chat packet) {
    	processInput(packet.message, packet.channel);
    }
    
    public void previosTab() {
    	if(activeTabIndex == 0)
    		return;
    	activeTabIndex--;
    	activeTab = tabs.get(activeTabIndex);
    	activeTab.hasNewMessage = false;
    	if(mc.ingameGUI.inSettings)
    		mc.ingameGUI.inSettings = false;
    }
    
    public void nextTab() {
    	if(activeTabIndex == tabs.size() - 1)
    		return;
    	activeTabIndex++;
    	activeTab = tabs.get(activeTabIndex);
    	activeTab.hasNewMessage = false;
    	if(mc.ingameGUI.inSettings)
    		mc.ingameGUI.inSettings = false;
    }

    public final static String join(String[] split) {
		return join(split, "");
	}
	
	public final static String join(String[] split, String glue) {
		return join(split, glue, 0);
	}
	
	public final static String join(String[] split, String glue, int start) {
		return join(split, glue, start, split.length - 1);
	}
	
	public static String join(String[] split, String glue, int start, int end) {
		start = start >= split.length ? split.length - 1 : start;
		end = end >= split.length ? split.length - 1 : end;
		StringBuilder sb = new StringBuilder();
		boolean set = false;
		for(int i = start; i <= end; ++i) {
			if(set) {
				sb.append(glue);
			}
			sb.append(split[i]);
			set = true;
		}
		return sb.toString();
	}
}
